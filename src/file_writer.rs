use ErrorKind::NotFound;
use io::ErrorKind;
use std::io;
use std::path::Path;
use tokio::fs::OpenOptions;
use tokio::io::AsyncReadExt;

use log::{ info, warn};


/// Merge the contents of the Source file with our own content
/// 
/// # Arguments
/// * `source_file_paths` - A slice of string containing the path to the source files, with the first being the primary source file (containing the SOA record)
/// * `destination_file_path` - A string containing the path to the destination file
/// 
/// # Returns
/// * `io::Result<()>` - A result indicating success or failure
/// 
pub async fn merge_source_files(source_file_paths:& [&str], destination_file_path: &str) -> io::Result<()> {
    info!("Merging source files: {:?} into destination file: {}", source_file_paths, destination_file_path);

    // Verify the source files exists
    if source_file_paths.is_empty() {
        warn!("No source files provided");
        let error = io::Error::new(ErrorKind::InvalidInput, "No source file provided");
        let result = Err(error);
        return result;
    } else {
        info!("Source files: {:?}", source_file_paths);
    }

    for source_file_path in source_file_paths {
        if !Path::new(source_file_path).exists() {
            warn!("Source file {} not found", source_file_path);
            let error = io::Error::new(NotFound, "File not found");
            let result = Err(error);
            return result;
        } else {
            info!("Source file {} found", source_file_path);
        }
    }


    // Merge the contents of the Source file with our own content
    // First, create a empty string
    let mut destination_file_content = String::new();
    // Add the delimiter comment
    destination_file_content.push_str("; This file was generated by the coredns-k8s-sync module\n");
    destination_file_content.push_str("; Do not edit this file manually\n");
    destination_file_content.push_str("; Original Source\n");

    // Add the source files content
    for source_file_path in source_file_paths {
        let content = read_content_from_source_file(source_file_path).await?;
        destination_file_content.push_str(&content);
    }
    

    info!("Writing to destination file: {}", destination_file_path);
    tokio::fs::write(destination_file_path, destination_file_content).await.unwrap();

    Ok(())
}

async fn read_content_from_source_file(source_file_path: &str) -> io::Result<String> {
    info!("Opening source file: {}", source_file_path);
    let mut source_file = OpenOptions::new()
        .read(true)
        .open(source_file_path)
        .await?;
    let mut source_file_content = String::new();
    info!("Reading source file: {}", source_file_path);
    source_file.read_to_string(&mut source_file_content).await?;
    return Ok(source_file_content);
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::fs::File;
    use tokio::io::AsyncReadExt;

    #[tokio::test]
    async fn test_merge_source_files() {
        // Print current working directory
        let cwd = std::env::current_dir().unwrap();
        println!("The current directory is {}", cwd.display());

        let test_file1 =  "examples/source.home.lab";
        let mut source_file1_path = String::new();
        source_file1_path.push_str(cwd.display().to_string().as_str());
        source_file1_path.push_str("/");
        source_file1_path.push_str(test_file1);
        println!("The source file is {}", source_file1_path);
        let file_name_1 = source_file1_path.clone();

        let test_file2 =  "examples/source.mandarin.compose";
        let mut source_file2_path = String::new();
        source_file2_path.push_str(cwd.display().to_string().as_str());
        source_file2_path.push_str("/");
        source_file2_path.push_str(test_file2);
        println!("The source file is {}", source_file2_path);
        let file_name_2 = source_file2_path.clone();

        let destination_file_name = "testdata/db.home.lab";
        let mut destination_file_path = String::new();
        destination_file_path.push_str(cwd.display().to_string().as_str());
        destination_file_path.push_str("/");
        destination_file_path.push_str(destination_file_name);
        println!("The destination file is {}", destination_file_path);
        let test_file_1 = destination_file_path.clone();

        // Call the function to test
        let result = merge_source_files(&[&file_name_1, &file_name_2], &test_file_1).await;

        // Check the result
        assert!(result.is_ok(), "Failed to merge source files: {:?}", result.err());

        // Check the content of the destination file
        let mut destination_content = String::new();
        let mut file = File::open(destination_file_path.clone()).await.unwrap();
        file.read_to_string(&mut destination_content).await.unwrap();
        println!("Destination file content: {}", destination_content);
        assert!(destination_content.contains("; Do not edit this file manually"), "Destination file content does not contain generated comment");
        assert!(destination_content.contains("$ORIGIN home.lab."), "Destination file content does not contain content from source.home.lab");
        assert!(destination_content.contains("portainer    IN A     192.168.178.123"), "Destination file content does not contain content from source.mandarin.compose");

        // Clean up
        tokio::fs::remove_file(destination_file_path).await.unwrap();
    }
}